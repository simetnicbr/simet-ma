#!/bin/sh
# SIMET2 MA - register and refresh agent registry information
# Copyright (c) 2018,2019 NIC.br <medicoes@simet.nic.br>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.  In every case, additional
# restrictions and permissions apply, refer to the COPYING file in the
# program Source for details.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License and the COPYING file in the program Source
# for details.

# parameters:
#   --boot   (optional) shorten wait times and not restart the service
#
# Pairing is disabled by having an empty virtual label (empty
# contents inside the file referenced by $AGENT_VLABEL_FILE)

set -e
set -o pipefail

umask 0022

RC=1
OUTFILE=
abend() {
	simet_log simet-ma daemon.err "error: $*"
	[ -n "$OUTFILE" ] && rm -f "$OUTFILE" 2>/dev/null
	exit "$RC"
}
clean_exit() {
	[ -n "$OUTFILE" ] && rm -f "$OUTFILE" 2>/dev/null
	exit 0
}

. @SIMETLIBDIR@/simet_lib.sh

# FIXME: We can and should remove this after the "point of no return"
# of support for downgrading without MA measurement continuity loss.
V1_AGENT_ID_FILE="@SIMETCONFDIR@/agent-id"
V1_AGENT_TOKEN_FILE="@SIMETCONFDIR@/agent.jwt"

SIMETMA_RECONFIG=${SIMETMA_RECONFIG:-/etc/init.d/simet-ma reload}

# Load hooks and overrides
simet_load_hooks register_ma

USERAGENT=$(get_http_useragent)
CURLOPT="$CURL_APIOPT --max-filesize 4000"
CURLOPT2=

case "$1" in
	--boot)
		shift
		CURLOPT2="$CURLOPT --retry 3 --retry-max-time 30"
		SIMETMA_RECONFIG=
	;;
esac
CURLOPT="$CURLOPT $CURLOPT2"

#overidable
simet_restart_services() {
	if [ -n "$SIMETMA_RECONFIG" ] ; then
		$SIMETMA_RECONFIG || true
	fi
	:
}

__gethash() {
	# $1 - file to hash
	[ -r "$1" ] || {
		echo ""
		return 0
	}
	sha256sum "$1" | sed -n '1 { s/[[:blank:]].*// ; p }'
	return 0
}
#overidable
#clobbers $OUTFILE contents!
write_lmap_agent() {
	if [ -z "$1" ] ; then
		rm -f  "$LMAP_AGENT_FILE"
		simet_log simet-ma daemon.notice "SIMET: removed LMAP agent-id"
	else
		cat <<- LMAPAGENTEOF >"$OUTFILE" || return 1
			{"ietf-lmap-control:lmap":{"agent":{"agent-id":"$1","report-agent-id":true}}}
		LMAPAGENTEOF
		HASHOLD=$(__gethash "$LMAP_AGENT_FILE") || HASHOLD=
		HASHNEW=$(__gethash "$OUTFILE") || return 1
		[ x"$HASHOLD" != x"$HASHNEW" ] && {
			LMAP_AGENT_DIR=$(dirname "$LMAP_AGENT_FILE")
			[ -d "$LMAP_AGENT_DIR" ] || mkdir -m 0755 -p "$LMAP_AGENT_DIR"
			cp -f "$OUTFILE" "$LMAP_AGENT_FILE" && chmod +r "$LMAP_AGENT_FILE"
		}
	fi
	:
}
#overridable
# $1: VTK (assumed to be stored in tmpfs)
write_access_tokens() {
	if [ -z "$1" ] ; then
		rm -f "$AGENT_VTK_FILE"
		simet_log simet-ma daemon.notice "SIMET: view_results token removed"
	else
		printf "%s" "$1" > "$AGENT_VTK_FILE"
		simet_log simet-ma daemon.info "SIMET: view_results token updated"
	fi
	:
}
#overridable
#clobbers $OUTFILE contents (write_lmap_agent)
write_agent_creds() {
	if [ -z "$AID" ] ; then
		rm -f "$AGENT_ID_FILE"
	elif [ "$AID" != "$OLDAID" ] ; then
		printf '%s\n' "$AID" > "$AGENT_ID_FILE"
	fi
	if [ -z "$AT" ] ; then
		rm -f "$AGENT_TOKEN_FILE"
	elif [ "$AT"  != "$OLDAT"  ] ; then
		printf '%s\n' "$AT" > "$AGENT_TOKEN_FILE"
	fi
	call write_lmap_agent "$AID" || :
	:
}

#must not change pairing data cache
__simet_consume_api_output() {
	AT=
	AID=
	PAIRED=0
	SID=$($JSONFILTER -i "$OUTFILE" -e "AID=@.agent_id" -e "AT=@.agent_token" -e "PAIRED=@.has_pairing") \
		|| abend "illegal response from agent-registry service"
	eval "$SID" || abend "internal error"
	PAIREDTO=$($JSONFILTER -i "$OUTFILE" -e "@.participant_id") || PAIREDTO=
	: > "$OUTFILE"

	call write_agent_creds || \
		simet_log simet-ma daemon.err "failed to write credentials!"
	:
}

__simet_agent_attributes() {
	[ -z "$SIMET_MAC_LABEL" ] && return 0
	echo "\"attributes\":{\"mac_address\":\"$SIMET_MAC_LABEL\"},"
}
__simet_agent_environment() {
	simet2_agentinfo && {
		echo "\"agent_environment_name\":\"$SIMET2_AGENT_ENVNAME\","
		echo "\"agent_environment_version\":\"$SIMET2_AGENT_ENVVERSION\","
	}
}

__simet_create_agent_apicall() {
	cat <<- EOFSCAG | \
	  curl $CURLOPT --retry 30 --retry-max-time 300 \
		-A "$USERAGENT" \
		-H "Content-type: application/json" \
		-f -X POST -o "$OUTFILE" -d @- -w "%{http_code}" \
		"$API_SIMET_AGENT_REG/v2/agents" \
	  || return 1
	{ $*
	  $(call __simet_agent_attributes)
	  $(call __simet_agent_environment)
	  "engine_name":"@SIMET_ENGINE_NAME@",
	  "engine_version":"@PACKAGEVERSION@",
	  "agent_family":"$SIMET2_AGENT_FAMILY" }
	EOFSCAG
	:
}
__simet_create_agent_common() {
	APIRES=$(__simet_create_agent_apicall "$@") || return 1
	[ "$APIRES" -eq 201 ] || return 1
	:
}

__simet_modify_agent_apicall() {
	if [ -z "$1" ] || [ "$1" = "DISABLED" ] ; then
		WP=false
		SC=
	else
		WP=true
		SC="\"secret\":\"$1\","
	fi
	cat <<- EOFSRAP | \
	  curl $CURLOPT --retry 3 --retry-max-time 30 \
	     -A "$USERAGENT" \
	     -X PUT -T - -f -H "Content-type: application/json" \
	     -H "Authorization: Bearer $AT" \
	     -o "$OUTFILE" -w "%{http_code}" \
	     "${API_SIMET_AGENT_REG}/v2/agents/$AID" \
	  || return 1
	{
	  $SC
	  $(call __simet_agent_attributes)
	  $(call __simet_agent_environment)
	  "engine_name":"@SIMET_ENGINE_NAME@",
	  "engine_version":"@PACKAGEVERSION@",
	  "agent_family":"$SIMET2_AGENT_FAMILY",
	  "waiting_for_pairing":$WP
	}
	EOFSRAP
	:
}
#overidable
simet_register_vlabel() {
	APIRES=$(__simet_modify_agent_apicall "$SIMET2_VLABEL") || {
		simet_log simet-ma daemon.err "could not talk to SIMET2 Agent Register API"
		return 1
	}
	[ "$APIRES" -eq 200 ] || {
		simet_log simet-ma daemon.err "SIMET2 Agent Register API reported error $APIRES"
		return 1
	}

	__simet_consume_api_output
	:
}

# used only for *first* register, not for recovery
#overidable
simet_create_agent() {
	V1AID=
	V1AT=
	V1JSON=
	[ -r "$V1_AGENT_ID_FILE" ] && V1AID=$(cat "$V1_AGENT_ID_FILE")
	[ -r "$V1_AGENT_TOKEN_FILE" ] && V1AT=$(cat "$V1_AGENT_TOKEN_FILE")
	[ -n "$V1AID" ] && [ -n "$V1AT" ] && V1JSON="\"agent_id\":\"$V1AID\",\"agent_token\":\"$V1AT\","

	__simet_create_agent_common "$V1JSON" || return $?

	[ -n "$AGENT_PAIRBKP_FILE" ] && rm -f "$AGENT_PAIRBKP_FILE"
	[ -n "$AGENT_PAIR_FILE" ] && rm -f "$AGENT_PAIR_FILE"

	__simet_consume_api_output
}
# used only for recovery into an anonymous MA
#overidable
simet_create_agent_for_recovery() {
	simet_log simet-ma daemon.crit "self-healing required, registering as a new measurement agent"
	__simet_create_agent_common || return $?
	__simet_consume_api_output
	:
}

#overidable
simet_save_pairing_recovery() {
	[ -n "$AGENT_PAIRBKP_FILE" ] && {
		if [ ! -r "$AGENT_PAIRBKP_FILE" ] ; then
			[ -r "$AGENT_PAIR_FILE" ] && {
				mv -f "$AGENT_PAIR_FILE" "$AGENT_PAIRBKP_FILE"
				simet_log simet-ma daemon.notice "pairing recovery information saved"
			}
		else
			simet_log simet-ma daemon.err "warning: pairing recovery info already present, using it"
			rm -f "$AGENT_PAIR_FILE"
		fi
	}
	:
}

#overridable
# $1: reason A-Za-z0-9_, to name bkp files
backup_invalid_id() {
	simet_log simet-ma daemon.debug "backup agent-id and tokens, suffix $1.bak"
	[ -e "$AGENT_ID_FILE" ] && mv -f "$AGENT_ID_FILE" "$AGENT_ID_FILE.$1.bak"
	[ -e "$AGENT_TOKEN_FILE" ] && mv -f "$AGENT_TOKEN_FILE" "$AGENT_TOKEN_FILE.$1.bak"
}

# pairing not cleaned up here
# $1: reason a-z0-9_, to name bkp files
__simet_invalidate_all() {
	call backup_invalid_id "$1"
	simet_log simet-ma daemon.notice "removing agent-id and tokens"
	OLDAT=
	OLDAID=
	AT=
	AID=
	call write_agent_creds || rm -f "$AGENT_ID_FILE" "$AGENT_TOKEN_FILE"
	__invalidate_tokens
	[ -n "$V1_AGENT_ID_FILE" ] && rm -f "$V1_AGENT_ID_FILE"
	[ -n "$V1_AGENT_TOKEN_FILE" ] && rm -f "$V1_AGENT_TOKEN_FILE"

	[ -d "$SIMET_RUNSTATE_DIR" ] && rm -f "$SIMET_RUNSTATE_DIR/vlabel-was-foreign"
}

#overidable
simet_refresh_agent_status() {
	APIRES=$( curl $CURLOPT -A "$USERAGENT" \
		-H "Authorization: Bearer $AT" \
		-X GET -o "$OUTFILE" -w "%{http_code}" \
		"${API_SIMET_AGENT_REG}/v2/agents/$AID" ) || return 1
	case "$APIRES" in
	204)
		simet_log simet-ma daemon.err "server doesn't know our agent-id!"
		;;
	401)
		simet_log simet-ma daemon.err "server reports our agent-id is outdated, in error, or unauthorized"
		;;
	403)
		simet_log simet-ma daemon.err "agent token is invalid, or has expired"
		;;
	410)
		simet_log simet-ma deamon.err "server reports our agent-id is outdated or duplicated (was it cloned? or from an old backup?)"
		# in case we fail to get a new one, ensure it is gone
		__simet_invalidate_all agstat_410
		;;
	200)
		__simet_consume_api_output
		return 0
		;;
	304)
		clean_exit
		;;
	500|400|404)
		abend "SIMET2 agent registry service unavailable"
		;;
        esac

	call simet_create_agent_for_recovery || abend "failed to create new identity for recovery"
	call simet_save_pairing_recovery
	return 0
}

__simet_pairing_recovery_apicall() {
	cat <<- EOFSPRC | \
	  curl $CURLOPT --retry 30 --retry-max-time 300 \
		-A "$USERAGENT" \
		-H "Authorization: Bearer $AT" \
		-H "Content-type: application/json" \
		-f -X POST -o "$OUTFILE" -d @- -w "%{http_code}" \
		"$API_SIMET_AGENT_REG/v2/agent-recovery/$AID" \
	  || return 1
	{ "engine_name":"@SIMET_ENGINE_NAME@",
	  "participant_id":"$1",
	  "secret":"$2" }
	EOFSPRC
	:
}
__simet_attempt_pairing_recovery() {
	APIRES=$(__simet_pairing_recovery_apicall "$1" "$2") || return 1
	[ "$APIRES" -eq 200 ] || return 1
	:
}
#overidable
simet_attempt_pairing_recovery() {
	OLDPAIR=$(cat "$AGENT_PAIRBKP_FILE" 2>/dev/null) || return 1

	RMOLD=$(find "$AGENT_PAIRBKP_FILE" -type f -mtime +14) || RMOLD=
	[ -n "$RMOLD" ] && rm -f "$AGENT_PAIRBKP_FILE"

	[ -z "$OLDPAIR" ] && return 1
	[ -z "$SIMET2_VLABEL" ] && return 1
	__simet_attempt_pairing_recovery "$OLDPAIR" "$SIMET2_VLABEL" || return 1
	SID2=$($JSONFILTER -i "$OUTFILE" -e "PAIRED=@.recovered") || return 1
	eval "$SID2" || return 1

	[ "$PAIRED" != "true" ] && [ "$PAIRED" != 1 ] && return 1

	rm -f "$AGENT_PAIRBKP_FILE"
	simet_log simet-ma daemon.notice "SIMET: pairing recovered"
	:
}

#overidable
simet_pairing_flow() {
	SIMET2_VLABEL=$(@BINDIR@/simet_read_vlabel.sh) || SIMET2_VLABEL=
	[ "$SIMET2_VLABEL" = "DISABLED" ] && SIMET2_VLABEL=
	[ -z "$SIMET2_VLABEL" ] && {
		# register as not available for pairing
		call simet_register_vlabel || true
		rm -f "$AGENT_PAIRBKP_FILE"
		return 0
	}

	if [ "$PAIRED" != "true" ] && [ "$PAIRED" != 1 ] ; then
		call simet_attempt_pairing_recovery && call simet_refresh_agent_status
	fi
	if [ "$PAIRED" != "true" ] && [ "$PAIRED" != 1 ] ; then
		call simet_register_vlabel || true
	fi

	if [ "$PAIRED" = "true" ] || [ "$PAIRED" = 1 ] ; then
		simet_log simet-ma daemon.notice "SIMET: this MA is paired to a participant in the SIMET2 web portal"
		[ -n "$AGENT_PAIRBKP_FILE" ] && rm -f "$AGENT_PAIRBKP_FILE"
		[ -n "$AGENT_PAIR_FILE" ] && {
			OLDPAIR=
			[ -r "$AGENT_PAIR_FILE" ] && OLDPAIR=$(cat "$AGENT_PAIR_FILE")
			[ x"$OLDPAIR" != x"$PAIREDTO" ] && echo "$PAIREDTO" > "$AGENT_PAIR_FILE"
		}
		call_hook pairing_paired
	fi
}

__invalidate_tokens() {
	VTK=
	call write_access_tokens "" || :
}
__consume_tokens_api_output() {
	VTK=
	SID=$($JSONFILTER -i "$OUTFILE" -e "VTK=@.access_tokens.view_results") \
		|| abend "illegal response from agent-registry service"
	eval "$SID" || abend "internal error"
	: > "$OUTFILE"

	call write_access_tokens "$VTK" || \
		simet_log simet-ma daemon.err "failed to store access tokens"
	:
}

#overridable
simet_update_tokens() {
	AGENT_ID="$1"
	AGENT_TOKEN="$2"
	APIRES=$( curl $CURLOPT -A "$USERAGENT" \
		-H "Authorization: Bearer ${AGENT_TOKEN}" \
		-X GET -o "$OUTFILE" -w "%{http_code}" \
		"${API_SIMET_AGENT_REG}/v2/agents/${AGENT_ID}/access_tokens" ) || return 1
	case "$APIRES" in
	204)
		simet_log simet-ma daemon.err "server doesn't know our agent-id!"
		;;
	401)
		simet_log simet-ma daemon.err "server reports our agent-id is outdated, in error, or unauthorized"
		;;
	403)
		simet_log simet-ma daemon.err "agent token is invalid, or has expired"
		;;
	410)
		simet_log simet-ma daemon.err "server requests removal of all access tokens"
		__invalidate_tokens
		;;
	200)
		__consume_tokens_api_output
		return 0
		;;
	500|400|404)
		simet_log simet-ma daemon.err "SIMET2 agent registry service unavailable"
		;;
        esac
	return 1
}

#overridable
# return 0 if ID is foreign/cloned, NZ otherwise
# $1: 1 if vlabel OK, 0 if vlabel was foreign (and has been fixed)
simet_detect_cloned_id() {
	# for now, if it was foreign, reset id. SIMETBox can do
	# better (it overrides this), and so could x86 with
	# dmidecode and UUIDs.
	[ $1 -eq 0 ] && \
		simet_log simet-ma daemon.warn "SIMET: vlabel flagged as foreign: assuming agent credentials came from other device"
	return "$1"
}

gettoken() {
	OLDAT=
	OLDAID=
	[ -r "$AGENT_ID_FILE" ] && OLDAID=$(cat "$AGENT_ID_FILE")
	[ -r "$AGENT_TOKEN_FILE" ] && OLDAT=$(cat "$AGENT_TOKEN_FILE")
	AID=$OLDAID
	AT=$OLDAT

	OUTFILE=$(mktemp -q -t simet-at-register.$$.XXXXXXXXXX) || abend "failed to create tmpfile"

	VL_GOOD=1
	[ -e "$SIMET_RUNSTATE_DIR/vlabel-was-foreign" ] && VL_GOOD=0
	call simet_detect_cloned_id "$VL_GOOD" && __simet_invalidate_all "ma_foreign"

	call_hook before_reginfo

	if [ -z "$OLDAT" ] || [ -z "$OLDAID" ] ; then
		call simet_create_agent || abend "could not register measurement agent"
	else
		call simet_refresh_agent_status || abend "could not update registration"
	fi

	call_hook after_reginfo

	if [ ! -r "$AGENT_ID_FILE" ] || [ -z "$AID" ] || [ ! -r "$AGENT_TOKEN_FILE" ] || [ -z "$AT" ] ; then
		call_hook failed_to_register
		abend "failed to register, please retry later"
	fi

	call simet_pairing_flow

	if call simet_update_tokens "$AID" "$AT" ; then
		call_hook access_tokens_updated || true
	else
		simet_log simet-ma daemon.err "SIMET: failed to retrieve access tokens"
	fi

	rm -f "$OUTFILE"
	OUTFILE=

	if [ x"$AID" != x"$OLDAID" ] || [ x"$AT"  != x"$OLDAT"  ] ; then
		simet_log simet-ma daemon.notice "SIMET: agent-id or authorization token has changed"
		call simet_restart_services
		call_hook reginfo_changed
	else
		call_hook reginfo_unchanged
	fi

	simet_log simet-ma daemon.info "SIMET: LMAP measurement agent id: $AID"
	:
}

[ -r "$AGENT_LOCK" ] || touch "$AGENT_LOCK" || abend "cannot create $AGENT_LOCK"
( flock -n -s 9 && gettoken ) <&- 9< "$AGENT_LOCK"
